package project.annotationschema.generator

import annotationdefinition.AnnotationID
import annotationdefinition.generator.AnnotationGenerator
import annotationdefinition.generator.UpdatableAnnotationGenerator
import annotationdefinition.generator.UpdateState
import annotationdefinition.target.DocumentTarget
import annotationdefinition.target.SpanTarget
import application.documentDAO
import document.Document
import document.addAnnotationResultForProject
import document.addGeneratedAnnotationDataForProject
import document.annotation.*
import document.annotation.Annotation
import org.slf4j.LoggerFactory
import project.Project
import project.annotationschema.DenormalizedAnnotationSchema
import project.annotationschema.denormalize

private val logger = LoggerFactory.getLogger("GeneratorExtensions")

/**
 * For an AnnotationSchema, execute all [AnnotationGenerator] and return the [GeneratedAnnotationData]
 */
suspend fun DenormalizedAnnotationSchema.generateAnnotationData(document: Document): GeneratedAnnotationData {
    val annotations = mutableMapOf<AnnotationID, Annotation<*>>()
    val generatedAnnotationData = GeneratedAnnotationData(System.currentTimeMillis(), annotations)
    this.elements.forEach { element ->
        logger.debug("AnnotationSchemaElement for ${element.annotationDefinition.id} EnableCondition exists: ${element.enableCondition != null}")
        element.annotationGenerator?.let { annotationGenerator ->
            try {
                if ((element.enableCondition == null || element.enableCondition.also {
                        logger.debug("Executing EnableCondition $it")
                    }.execute(
                        document,
                        annotations
                    ).also {
                        logger.debug("EnableCondition result: $it")
                    })
                ) {
                    val generatedAnnotation = annotationGenerator.generateAnnotation(
                        document, generatedAnnotationData
                    )
                    if (element.target is DocumentTarget && generatedAnnotation is DocumentTargetAnnotation) {
                        annotations[element.annotationDefinition.id] = generatedAnnotation
                    } else if (element.target is SpanTarget && generatedAnnotation is SpanTargetAnnotation) {
                        annotations[element.annotationDefinition.id] = generatedAnnotation
                    } else {
                        throw IllegalStateException("Target of $element does not fit result type of generated annotation $generatedAnnotation")
                    }
                }
            } catch (e: Exception) {
                logger.error("Could not generate annotation with $annotationGenerator: ${e.message}")
            }
        }
    }
    if(generatedAnnotationData.annotations.isNotEmpty()) {
        return generatedAnnotationData
    } else {
        throw IllegalStateException("Not a single annotation was generated, cannot generate annotation data")
    }
}

suspend fun DenormalizedAnnotationSchema.generateAnnotationDataBulk(documents: List<Document>): Map<Document, GeneratedAnnotationData> {
    val generatedAnnotationDataPerDocument = mutableMapOf<Document, GeneratedAnnotationData>()

    fun getOrPutGeneratedAnnotationData(document: Document): GeneratedAnnotationData {
        return generatedAnnotationDataPerDocument[document] ?: generatedAnnotationDataPerDocument.let {
            val generatedAnnotationData = GeneratedAnnotationData(System.currentTimeMillis(), mutableMapOf())
            it[document] = generatedAnnotationData
            generatedAnnotationData
        }
    }

    this.elements.forEach { element ->
        logger.info("AnnotationSchemaElement for ${element.annotationDefinition.id} EnableCondition exists: ${element.enableCondition != null}")
        element.annotationGenerator?.let { annotationGenerator ->
            try {
                val documentsToGenerateFor = documents.filter { document ->
                    (element.enableCondition == null || element.enableCondition.execute(
                        document, getOrPutGeneratedAnnotationData(document).annotations))
                }
                logger.info("Of ${documents.size} documents, ${documentsToGenerateFor.size} will get annotation generated by ${annotationGenerator
                    .id}")
                val generatedAnnotations = annotationGenerator.generateAnnotationBulk(
                    documentsToGenerateFor.map { document ->
                        document to getOrPutGeneratedAnnotationData(document)
                    }
                )
                logger.info("${generatedAnnotations.size} annotations were generated by ${annotationGenerator.id}")
                generatedAnnotations.forEach { (document, generatedAnnotation) ->
                    if ((element.target is DocumentTarget && generatedAnnotation is DocumentTargetAnnotation) || (element.target is SpanTarget &&
                                generatedAnnotation is SpanTargetAnnotation)) {
                        getOrPutGeneratedAnnotationData(document).annotations.put(element.annotationDefinition.id, generatedAnnotation)
                    } else {
                        throw IllegalStateException("Target of $element does not fit result type of generated annotation $generatedAnnotation")
                    }
                }
            } catch (e: Exception) {
                logger.error("Could not generate annotation with $annotationGenerator: ${e.message}")
            }
        }
    }
    return generatedAnnotationDataPerDocument
}

/**
 * Given a [Project], generate missing annotations for all documents for the project and update the documents. This method does it multiple chunks,
 * given a size parameter
 */
suspend fun Project.generateMissingAnnotationsForAllDocumentsBulk(chuckSize: Int = 100, limit: Int = Int.MAX_VALUE) {
    if(annotationSchema.elements.any { it.annotationGeneratorID != null }) {
        val denormalizedAnnotationSchema = annotationSchema.denormalize()
        // Only generate if we have generators which actually can generate
        if(denormalizedAnnotationSchema.elements.any { element ->
                element.annotationGenerator?.let { generator ->
                    generator !is UpdatableAnnotationGenerator || (generator.versions.any { it.updateState == UpdateState.UPDATED }) }  == true }
        ) {
            val documentsToGenerateFor = documentDAO.findForProjectAndMissingGeneratedAnnotationData(this, limit)
            logger.info("Generating missing annotations for project $id in bulk (${documentsToGenerateFor.size} documents)")
            documentsToGenerateFor.chunked(chuckSize).forEach { documents ->
                val generatedAnnotationDataPerDocument = denormalizedAnnotationSchema.generateAnnotationDataBulk(documents)
                logger.info("Generate annotations for ${documents.size} documents (${generatedAnnotationDataPerDocument.size} results)")
                val updatedDocuments = generatedAnnotationDataPerDocument.mapNotNull { (document, generatedAnnotationData) ->
                    if (generatedAnnotationData.annotations.isNotEmpty()) {
                        document.addGeneratedAnnotationDataForProject(this, generatedAnnotationData)
                        val annotationResult = generatedAnnotationData.buildAnnotationResult(
                            document, this.id,
                            denormalizedAnnotationSchema
                        )
                        document.addAnnotationResultForProject(
                            this, annotationResult,
                            checkWebHooks = true, applyPolicy = true, annotationSchema = denormalizedAnnotationSchema
                        )
                        document
                    } else {
                        logger.warn("Could not generate annotations for ${document.id}")
                        null
                    }
                }
                try {
                    val bulkWriteResult = documentDAO.bulkReplace(updatedDocuments)
                    if(bulkWriteResult.wasAcknowledged()) {
                        logger.info("Bulk write result: $bulkWriteResult")
                    } else {
                        logger.error("Bulk write result was not acknowledged: $bulkWriteResult")
                    }
                } catch (e: Exception) {
                    logger.error("Could not bulk update documents after generating annotations", e)
                }
            }
        } else {
            logger.info("No possibility to update for project ${this.id}")
        }
    }
}

